PACKAGE

package mymy
import "mymysql"

CONSTANTS

const (
    MYSQL_TYPE_DECIMAL     = 0x00
    MYSQL_TYPE_TINY        = 0x01 // int8, uint8
    MYSQL_TYPE_SHORT       = 0x02 // int16, uint16
    MYSQL_TYPE_LONG        = 0x03 // int32, uint32
    MYSQL_TYPE_FLOAT       = 0x04 // float32
    MYSQL_TYPE_DOUBLE      = 0x05 // float64
    MYSQL_TYPE_NULL        = 0x06 // nil
    MYSQL_TYPE_TIMESTAMP   = 0x07 // *Timestamp
    MYSQL_TYPE_LONGLONG    = 0x08 // int64, uint64
    MYSQL_TYPE_INT24       = 0x09
    MYSQL_TYPE_DATE        = 0x0a
    MYSQL_TYPE_TIME        = 0x0b
    MYSQL_TYPE_DATETIME    = 0x0c // *Datetime
    MYSQL_TYPE_YEAR        = 0x0d
    MYSQL_TYPE_NEWDATE     = 0x0e
    MYSQL_TYPE_VARCHAR     = 0x0f
    MYSQL_TYPE_BIT         = 0x10
    MYSQL_TYPE_NEWDECIMAL  = 0xf6
    MYSQL_TYPE_ENUM        = 0xf7
    MYSQL_TYPE_SET         = 0xf8
    MYSQL_TYPE_TINY_BLOB   = 0xf9
    MYSQL_TYPE_MEDIUM_BLOB = 0xfa
    MYSQL_TYPE_LONG_BLOB   = 0xfb
    MYSQL_TYPE_BLOB        = 0xfc // Blob
    MYSQL_TYPE_VAR_STRING  = 0xfd // []byte
    MYSQL_TYPE_STRING      = 0xfe // string
    MYSQL_TYPE_GEOMETRY    = 0xff

    MYSQL_UNSIGNED_MASK = uint16(1 << 15)
)
MySQL protocol types.

mymysql uses only some of them for send data to the MySQL server. Used
MySQL types are marked with a comment contains mymysql type that uses it.

const (
    // Client send and receive, mymysql representation for send / receive
    TINYINT   = MYSQL_TYPE_TINY      // int8 / int8
    SMALLINT  = MYSQL_TYPE_SHORT     // int16 / int16
    INT       = MYSQL_TYPE_LONG      // int32 / int32
    BIGINT    = MYSQL_TYPE_LONGLONG  // int64 / int64
    FLOAT     = MYSQL_TYPE_FLOAT     // float32 / float32
    DOUBLE    = MYSQL_TYPE_DOUBLE    // float64 / float32
    TIME      = MYSQL_TYPE_TIME      // *Datetime / *Datetime
    DATE      = MYSQL_TYPE_DATE      // *Datetime / *Datetime
    DATETIME  = MYSQL_TYPE_DATETIME  // *Datetime / *Datetime
    TIMESTAMP = MYSQL_TYPE_TIMESTAMP // *Timestamp / *Datetime
    CHAR      = MYSQL_TYPE_STRING    // string / []byte
    BLOB      = MYSQL_TYPE_BLOB      // Blob / []byte
    NULL      = MYSQL_TYPE_NULL      // nil


    // Client send only, mymysql representation for send
    OUT_TEXT      = MYSQL_TYPE_STRING // string
    OUT_VARCHAR   = MYSQL_TYPE_STRING // string
    OUT_BINARY    = MYSQL_TYPE_BLOB   // Blob
    OUT_VARBINARY = MYSQL_TYPE_BLOB   // Blob


    // Client receive only, mymysql representation for receive
    IN_MEDIUMINT  = MYSQL_TYPE_INT24       // int32
    IN_YEAR       = MYSQL_TYPE_SHORT       // int16
    IN_BINARY     = MYSQL_TYPE_STRING      // []byte
    IN_VARCHAR    = MYSQL_TYPE_VAR_STRING  // []byte
    IN_VARBINARY  = MYSQL_TYPE_VAR_STRING  // []byte
    IN_TINYBLOB   = MYSQL_TYPE_TINY_BLOB   // []byte
    IN_TINYTEXT   = MYSQL_TYPE_TINY_BLOB   // []byte
    IN_TEXT       = MYSQL_TYPE_BLOB        // []byte
    IN_MEDIUMBLOB = MYSQL_TYPE_MEDIUM_BLOB // []byte
    IN_MEDIUMTEXT = MYSQL_TYPE_MEDIUM_BLOB // []byte
    IN_LONGBLOB   = MYSQL_TYPE_LONG_BLOB   // []byte
    IN_LONGTEXT   = MYSQL_TYPE_LONG_BLOB   // []byte


    // MySQL 5.x specific
    IN_DECIMAL = MYSQL_TYPE_NEWDECIMAL // TODO
    IN_BIT     = MYSQL_TYPE_BIT        // []byte
)
Mapping of MySQL types to (prefered) protocol types. Use it if you create
your own Raw value.

Comments contains corresponding types used by mymysql. string type may be
replaced by []byte type and vice versa. []byte type is native for sending
on a network, so any string is converted to it before sending. Than for
better preformance use []byte.


VARIABLES

var (
    WR_BUF_ERROR          = os.NewError("write buffer/packet too short")
    SEQ_ERROR             = os.NewError("packet sequence error")
    PKT_ERROR             = os.NewError("malformed packet")
    PKT_LONG_ERROR        = os.NewError("packet too long")
    UNEXP_NULL_LCS_ERROR  = os.NewError("unexpected null LCS")
    UNEXP_NULL_LCB_ERROR  = os.NewError("unexpected null LCB")
    UNEXP_NULL_DATE_ERROR = os.NewError("unexpected null datetime")
    UNK_RESULT_PKT_ERROR  = os.NewError("unexpected or unknown result packet")
    NOT_CONN_ERROR        = os.NewError("not connected")
    ALREDY_CONN_ERROR     = os.NewError("not connected")
    BAD_RESULT_ERROR      = os.NewError("unexpected result")
    UNREADED_ROWS_ERROR   = os.NewError("there are unreaded rows")
    BIND_COUNT_ERROR      = os.NewError("wrong number of values for bind")
    BIND_UNK_TYPE         = os.NewError("unknown bind value type")
    RESULT_COUNT_ERROR    = os.NewError("wrong number of result columns")
    BAD_COMMAND_ERROR     = os.NewError("comand isn't text SQL nor *Statement")
    WRONG_DATE_LEN_ERROR  = os.NewError("wrong datetime/timestamp length")
    UNK_MYSQL_TYPE_ERROR  = os.NewError("unknown MySQL type")
)


FUNCTIONS

func DecodeU16(buf []byte) uint16

func DecodeU24(buf []byte) uint32

func DecodeU32(buf []byte) uint32

func DecodeU64(buf []byte) (rv uint64)

func EncodeDatetime(dt *Datetime) *[]byte

func EncodeU16(val uint16) *[]byte

func EncodeU24(val uint32) *[]byte

func EncodeU32(val uint32) *[]byte

func EncodeU64(val uint64) *[]byte

func IsDatetimeZero(dt *Datetime) bool

func NbinToNstr(nbin *[]byte) *string

func NstrToNbin(nstr *string) *[]byte


TYPES

type Blob []byte

type Datetime struct {
    Year                             int16
    Month, Day, Hour, Minute, Second uint8
    Nanosec                          uint32
}

func TimeToDatetime(tt *time.Time) *Datetime

func (dt *Datetime) String() string

type Error struct {
    // contains unexported fields
}

func (err Error) String() string

type Field struct {
    Catalog  string
    Db       string
    Table    string
    OrgTable string
    Name     string
    OrgName  string
    DispLen  uint32
    //  Charset  uint16
    Flags uint16
    Type  byte
    Scale byte
}

type MySQL struct {

    // Maximum packet size that client can accept from server.
    // Default 16*1024*1024-1. You may change it before connect.
    MaxPktSize int

    // Debug logging. You may change it at any time.
    Debug bool
    // contains unexported fields
}
MySQL connection handler

func New(proto, laddr, raddr, user, passwd string, db ...string) (my *MySQL)
Create new MySQL handler. The first three arguments are passed to net.Bind
for create connection. user and passwd are for authentication. Optional db
is database name (you may not specifi it and use Use() method later).

func (my *MySQL) Close() (err os.Error)
Close connection to the server

func (my *MySQL) Connect() (err os.Error)
Establishes a connection with MySQL server version 4.1 or later.

func (my *MySQL) Ping() (err os.Error)
Send PING packet to server.

func (my *MySQL) Prepare(sql string) (stmt *Statement, err os.Error)
Prepare server side statement. Return statement handler.

func (my *MySQL) Query(command interface{}, params ...interface{}) (rows []*Row, res *Result, err os.Error)
This call Start and next call GetTextRow once or more times. It read
all rows from connection and returns they as a slice.

func (my *MySQL) Start(command interface{}, params ...interface{}) (res *Result, err os.Error)
Start new query session.

command can be SQL query (string) or a prepared statement (*Statement).

If the command is a string and you specify the parameters, the SQL string
will be a result of fmt.Sprintf(command, params...).

If the command is a prepared statement, params will be binded to this
statement before execution.

You must get all result rows (if they exists) before next query.

func (my *MySQL) Use(dbname string) (err os.Error)
Change database

type Raw struct {
    // contains unexported fields
}

type Result struct {
    FieldCount int
    Fields     []*Field       // Fields table
    Map        map[string]int // Maps field name to column number

    Message      []byte
    AffectedRows uint64
    InsertId     uint64
    WarningCount int
    Status       uint16
    // contains unexported fields
}

func (res *Result) End() (err os.Error)
Read all unreaded rows and discard them. All rows must be read before next
query or other command.

func (res *Result) GetRow() (row *Row, err os.Error)
Get data row from a server. This method reads one row of result directly
from network connection (without rows buffering on client side).

type Row struct {
    Data []interface{}
}
Result row. Data field is a slice that contains values for any column of
received row.

If row is a result of ordinary text query, an element of Data field can be
[]byte slice, contained result text or nil if NULL is returned.

If it is result of prepared statement execution, an element of Data field
can be: intXX, uintXX, floatXX, []byte, *Datetime or nil.

func (tr *Row) Bin(nn int) (bin []byte)
Get the nn-th value and return it as []byte ([]byte{} if NULL)

func (tr *Row) Int(nn int) (val int)
Get the nn-th value and return it as int. Return 0 if value is NULL or
conversion is impossible.

func (tr *Row) IntErr(nn int) (val int, err os.Error)
Get the nn-th value and return it as int (0 if NULL). Return error if
conversion is impossible.

func (tr *Row) MustInt(nn int) (val int)
Get the nn-th value and return it as int (0 if NULL). Panic if conversion is
impossible.

func (tr *Row) MustUint(nn int) (val uint)
Get the nn-th value and return it as uint (0 if NULL). Panic if conversion is
impossible.

func (tr *Row) Str(nn int) (str string)
Get the nn-th value and return it as string ("" if NULL)

func (tr *Row) Uint(nn int) (val uint)
Get the nn-th value and return it as uint. Return 0 if value is NULL or
conversion is impossible.

func (tr *Row) UintErr(nn int) (val uint, err os.Error)
Get the nn-th value and return it as uint (0 if NULL). Return error if
conversion is impossible.

type ServerInfo struct {
    // contains unexported fields
}

type Statement struct {
    Fields []*Field
    Map    map[string]int // Maps field name to column number

    FieldCount   int
    ParamCount   int
    WarningCount int
    Status       uint16
    // contains unexported fields
}

func (stmt *Statement) BindParams(params ...interface{})
Bind input data for the parameter markers in the SQL statement that was
passed to Prepare.

params may be a parameter list (slice), a struct or a pointer to the struct.
A struct field can by value or pointer to value. A parameter (slice element)
can be value, pointer to value or pointer to pointer of value.
Values may be of the folowind types: intXX, uintXX, floatXX, []byte, Blob,
string, Datetime, Timestamp, Raw.

func (stmt *Statement) Delete() (err os.Error)
Destroy statement on server side. Client side handler is invalid after this
command.

func (stmt *Statement) Execute() (res *Result, err os.Error)

func (stmt *Statement) Reset() (err os.Error)
Resets a prepared statement on server: data sent to the server, unbuffered
result sets and current errors.

type Timestamp Datetime

func TimeToTimestamp(tt *time.Time) *Timestamp

func (ts *Timestamp) String() string

type Value struct {
    // contains unexported fields
}

func (val *Value) Len() int


SUBDIRECTORIES

	.git
	examples
	godoc
